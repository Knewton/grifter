#!/usr/bin/env ruby
require 'optparse'

require_relative '../lib/grifter'

Log = Grifter::Log

Log.level = Logger::INFO

#Deal with the cmd line
def parse_cmd_line
  options = {
      files: [],
      config_file: 'grifter.yml',
      authenticate: true,
      #by leaving environment unset, grift will use GRIFTER_ENVIRONMENT variable if no -e is used on cmd line
      #environment: nil,
  }

  optparse = OptionParser.new do |opts|
    opts.banner = %Q|
      Grifter HTTP JSON APIs Client
      example, run a data script: bin/grifter -f script.rb
      example, call a method:     bin/grifter <grift method name>

    |

    opts.on("-f", "--script=FILENAME",
      "specify a script file to run") { |file| options[:files] << file }

    opts.on("-d", "--script-dir=dir",
      "specify a directory of grift scripts, run all of them") { |dir| options[:files] += Dir["#{dir}/**/*.rb"] }

    opts.on("-v", "--verbose",
      "debug logging, see every request and response in detail") { Log.level = Logger::DEBUG }

    opts.on("-q", "--quiet",
      "quiet logging, warnings and errors only") { Log.level = Logger::WARN }

    opts.on("-c", "--config=FILENAME",
      "config filename") { |fn| options[:config_file] = fn }

    opts.on('-e', '--environment=ENVIRONMENT',
           "environment name") { |e| options[:environment] = e.to_sym }

    opts.on("-n", "--no-authenticate",
           "Do not authenticate") { options[:authenticate] = false }

  end
  optparse.parse!
  options
end
options = parse_cmd_line

grifter = Grifter.new options


if not(ARGV.empty?)
  #a grift method has been specified on the command line
  method = ARGV.shift
  response = grifter.send(method.to_sym, *ARGV)
  puts response.inspect

elsif not(options[:files].empty?)
  #some grift files were specified on the command line?
  options[:files].each do |script_file|
    grifter.run_script_file(script_file)
  end

else
  Kernel.abort "Nothing to do?  use -f or give a method name on the cmd line"
end
